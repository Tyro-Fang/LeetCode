## 解题思路
### 递归
第一种方式是采用递归的方式进行求解，代码很容易理解。
若是想让s1在经过一系列的分割交换后能够得到s2，有三种情况
1.s1不经过任何操作即可得到s2
2.s1首先经过分割后子字符串分别进行一系列操作可以得到s2
3.s1经过分割后，两个子字符串交换位置后经过一系列的处理可以得到s2

所以，采用递归的条件是
~~~
 (isScramble（s1[0:i],s2[0:i])&&isScramble（s1[i:],s2[i:])
 ||
(isScramble（s1[0:i],s2[len-i:])&&isScramble（s1[i:],s2[0:len-i])
||s1==s2
~~~
再加上特定的剪枝操作，包括s1与s2长度要一致，所包含字符数目一致等。


若是想避免重复比较，可以将已经完成比较的字符串利用map存储，每次递归首先查询表里是否已经有记录即可。理论上说此种方法的时间复杂度要小于不采用存储结果方式，但是若是字符串长度较小，存取map与拼接字符串等操作所需时间可能大于递归所用时间导致直接递归运行速度较快。

###动态规划
若是想使用动态规划，就需要将所有情况都进行比较比较，利用dp[len][i][j]代表s1[i:i+len]与s2[j:j+len]是否满足条件
每次只比较分割后的左半部分的字符串是否满足条件，这样最后dp[length][0][0]即为最终两个字符串是否满足条件的值
